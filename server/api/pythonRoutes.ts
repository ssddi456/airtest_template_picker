import { Router } from 'express';
import type { Request, Response } from 'express';
import {
  getAllAnnotations,
  calculateRelativeRect,
} from '../lib/fileStorage';
import { promises as fs } from 'fs';
import path from 'path';
import sharp from 'sharp';

const router = Router();
const OUTPUT_FILE = path.join(process.cwd(), 'output', 'templates.py');
const CROPPED_DIR = path.join(process.cwd(), 'data/cropped');
const SCREENSHOTS_DIR = path.join(process.cwd(), 'data/screenshots');

// Clear directory contents
async function clearDirectory(dirPath: string): Promise<void> {
  try {
    const files = await fs.readdir(dirPath);
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      const stat = await fs.stat(filePath);
      if (stat.isDirectory()) {
        await fs.rm(filePath, { recursive: true, force: true });
      } else {
        await fs.unlink(filePath);
      }
    }
  } catch (error) {
    // Directory doesn't exist yet, ignore
  }
}

// Generate Python code (can be imported and called from other modules)
export async function generatePythonCode(): Promise<{ success: boolean; error?: string; code?: string }> {
  try {
    const annotations = await getAllAnnotations();

    // Clear cropped directory
    await fs.mkdir(CROPPED_DIR, { recursive: true });
    await clearDirectory(CROPPED_DIR);

    // Crop images for each annotation
    for (const data of annotations) {
      const screenshotPath = path.join(SCREENSHOTS_DIR, data.screenshotId);

      try {
        // Check if screenshot file exists
        await fs.access(screenshotPath);

        for (const annotation of data.currentAnnotations) {
          const croppedFilename = `${annotation.id}.png`;
          const croppedPath = path.join(CROPPED_DIR, croppedFilename);

          // Use sharp to crop the image
          await sharp(screenshotPath)
            .extract({
              left: Math.round(annotation.rect.x),
              top: Math.round(annotation.rect.y),
              width: Math.round(annotation.rect.width),
              height: Math.round(annotation.rect.height)
            })
            .toFile(croppedPath);
        }
      } catch (error) {
        // Screenshot file doesn't exist or error, skip this annotation
        console.warn(`Warning: Could not crop image for ${data.screenshotId}:`, error);
      }
    }

    // Generate Python code
    let pythonCode = `# Auto-generated by Airtest Template Manager
# Generated at: ${new Date().toISOString()}
# Do not edit manually

from airtest.core.api import *

# Template definitions grouped by screenshot
Templates = {

`;

    // Add each template
    for (const data of annotations) {
      for (const annotation of data.currentAnnotations) {
        const croppedFilename = `${annotation.id}.png`;
        const croppedPath = `data/cropped/${croppedFilename}`;

        pythonCode += `  '${annotation.name}': Template(
    r'${croppedPath}',
    record_pos=((${annotation.rect.x}, ${annotation.rect.y}),
    target_pos=${annotation.targetPos},
    resolution=(${data.sourceSize.width}, ${data.sourceSize.height})
  ),

`;
      }
    }

    pythonCode += `}

print("Templates loaded successfully!")
print(f"Total templates: ${annotations.reduce((sum, data) => sum + data.currentAnnotations.length, 0)}")
`;

    // Save to output file
    await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true });
    await fs.writeFile(OUTPUT_FILE, pythonCode);

    return { success: true, code: pythonCode };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}

// Generate Python code endpoint
router.post('/generate', async (req: Request, res: Response) => {
  const result = await generatePythonCode();

  if (result.success) {
    res.json({
      success: true,
      data: {
        message: 'Python code generated',
        path: 'output/templates.py',
      },
    });
  } else {
    res.status(500).json({ success: false, error: result.error });
  }
});

// Get generated Python code
router.get('/', async (req: Request, res: Response) => {
  try {
    // Check if file exists
    try {
      await fs.access(OUTPUT_FILE);
    } catch {
      return res.json({
        success: true,
        data: {
          code: null,
          message: 'No Python code generated yet. Save some annotations first.',
        },
      });
    }

    // Read file content
    const code = await fs.readFile(OUTPUT_FILE, 'utf-8');
    res.json({
      success: true,
      data: {
        code,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, error: String(error) });
  }
});

export default router;
